---
layout: 	post
title: 		"Oracle基础知识总结"
subtitle:   "Oracle baseic"
date: 		2018-3-13 21:21
author: 	"xutaotao"
header-img: "img/post-bg-js-version.jpg"
tags:
  - 数据库
---


## 1.1 Oracle服务器系列

### 1.1.1数据库服务器

Oracle服务器实现的处理模型是客户端--服务器处理模型（两层模型）。

客户端生成SQL命令，服务器层执行它们。

用户进程和服务器进程之间使用的通信协议是Oracle的专有协议--Oracle Net

客户端层由两个组件组成：用户和用户进程。

服务器层有三个组件：执行SQL的服务器进程、实例和数据库本身。

### 1.1.2应用服务器

Web应用程序通常在三层或三层以上的体系结构中运行：数据库层管理数据访问，客户端层处理与用户通信的本地窗口管理，中间层执行生成用户界面和数据库SQL调试的程序逻辑

### 1.1.3企业管理器

Oracle Enterprise Manager的三种形式：
- Database Control
- Application Server Control
- Grid Control


## 1.2基本概念

### 1.2.1 Oreacle概念

Oracle Database Server由称为实例和数据库的两个主要组件构成。

### 1.2.2 SQL概念

- 表、行、列
- 基本查询


## 1.3数据库结构

### 1.3.1单体例数据库体系结构

实例由内存结构和进程组成。在单体实例环境中，一个实例打开一个数据库。

- 系统全局区（system gloabal area,SGA）：在操作系统提供的共享内存段实现的内存结构。SGA在实例启动时分配，在关闭时释放。

- 程序全局区（program global area，PGA）：与每一个服务器相关的是一个非共享内存区。与SGA不同，此区是会话专用的。

**考点：SGA内存由所有后台和前台进程共享，PGA内存仅供分配到的会话的前台进程访问。SGA和PGA内存都可以实现自动管理**

构成Oracle数据库的物理结构是数据文件、重做日志和控制文件

单体例数据库的体系结构由4个交互组件构成：

- 用户与用户进程交互
- 用户进程与服务器进程交互
- 服务器进程与实例交互
- 实例与数据库交互

### 1.3.2分布式系统体系结构
分布式环境中，有多种组合实例与数据库的方式。主要有如下几种：

- 实时应用群集（Real Application Clusters,RAC）,多个实例打开一个数据库
- 流，多个Oracle服务器相互之间传播事务
- 数据保护，主数据库更新备用数据库





### 1.4实例内存结构
Oracle实例由称为系统全局区（SGA）的共享内存块以及大量的后台进程构成。SAG至少包含三种数据结构：

- 数据库缓冲区缓存
- 日志缓冲区
- 共享池

还可能包含：

- 大池
- Java池
- 流池

**考点：哪些SGA结构是必需的，那些是可选的**

- 数据库缓冲区缓存，日志缓冲区和共享池是必须的，而大池、Java池和流池是可选的。

### 1.4.1数据库缓冲区缓存
数据库缓冲区缓存是Oracle用来执行SQL的工作区域。在更新数据时，用户的会话不直接更新磁盘的数据。包含关键数据的数据块首先复制到数据库缓冲区缓存。更改（增删改）应用于数据库缓冲区缓存中这些数据块的副本。此外，块在缓存中保留一段时间，直至其占有的缓冲区需要缓存另一个块为止。查询数据时，数据也要经过缓存。

数据库缓冲区缓存在实例启动时分配。9i前，如果不重新启动数据库实例，就无法在随后重调数据库缓冲区缓存的大小。9i后可以随时调整大小，可手动也可以自动。

**考点：可以动态调整数据库缓冲区缓存的大小，也可以对其进行自动管理**

### 1.4.2日志缓存区
日志缓存区是小型的、用于短期存储将写入到磁盘上的重做日志的变更向量的临时区域。

日志缓冲区在启动时分配，如果不重新启动实例，就不能在随后调整其大小。它是一个循环缓冲区。

**考点：日志缓冲区的大小固定不变，在启动实例时被设置为固定值。无法对其进行自动管理。**

### 1.4.3共享池
共享池是最复杂的SGA结构。分为许多子结构，这些子结构由Oracle服务器内部管理。

- 库缓存
- 数据字典缓存
- PL/SQL区
- SQL查询和PL/SQL函数结果缓存

**考点：共享池的大小是动态的，可以对其进行自动管理**

- 1.库缓存
库缓存是内存区域，按其已分析的格式存储最近执行的代码。

- 2.数据字典缓存
数据字典缓存有时称为“行缓存”。它存储最近使用的对象定义：表、索引、用户和其他元数据定义的描述。

- 3.PL/SQL区
存储的PL/SQL对象是过程、函数、打包的过程、打包的函数、对象类型定义和触发器

- 4.SQL查询和PL/SQL函数结果缓存

- 5.设置共享池的大小
设置共享池的大小将对性能产生重要的影响。

### 1.4.4大池
大池是一个可选区域，如果创建大池，则那些在不创建大池的情况下使用共享池内存的不同进程将自动使用大池。

**考点：大池的大小可以动态调整，而且可以自动管理**

### 1.4.5Java池
只有当应用程序需要在数据库中运行Java存储过程时，才需要Java池：此池用作实例化Java对象所需的堆空间。

*注：Java代码不在Java池中缓存，Java代码在共享池中缓存，与PL/SQL代码的缓存方式相同。*

**考点：Java池的大小是动态的，而且可以自动管理**

### 1.4.6流池
流池供Oracle流使用。

**考点：流池的大小是动态的，而且可以自动管理**

## 1.5 实例进程结构
- 系统监视器（System Monitor,SMON）
SMON通过查找和验证数据库控制文件来安装数据库

- 进程监视器（Process Monitor,PMON）
POMN监视所有服务器进程，并检测会话中的任何问题。

**考点：如果会话异常终止，那么活动的事务会发生什么事情？PMON后台进程将回滚活动事务**

- 数据库写入器（Database Writer,DBWR）
会话通常并不将数据写入磁盘。会话将数据写入数据库缓冲区缓存中的缓冲区。由数据库写入器负责在随后将缓冲区写入磁盘。

**考点：究竟需要多少个数据库写入器？默认数量就很合适。添加多了数据库写入器，性能可能会有所提升，但通常需要先考虑调整内存。**

**考点：DBWR会在哪些情况下执行写操作？没有任何可用缓冲区、脏缓冲区过多、遇到三秒超时或遇到检查点**

**考点：在提交事务时，DBWR有何举动？答案是：他什么都不做。**

- 日志写入器（Log Writer,LGWR）

**考点：LGWR会在哪些情况下将日志缓冲区转储到磁盘？会话发出COMMIT时、缓冲区的占用率达到1/3时，DBWR正好执行写入前。**

检查点进程（Checkpoint Process,CKPT）

**考点：何时出现完全检查点？只会应请求这么做，或者在有序关闭数据库时出现**

## 1.6数据库存储结构

### 1.6.1 物理数据库结构
**考点：Oracle数据库包括三类必须的文件：控制文件、联机重做日志文件以及任意数量的数据文件。**

- 1.控制文件

- 2.联机重做日志文件

- 3.数据文件

- 4.其他数据库文件

### 1.6.2 逻辑数据库结构
表空间——段——区间——Oracle块


## 单实例体系结构
- oracle服务器是连接到数据库的实例
- 实例包括共享内存（SGA）以及一组后台进程
- 数据库是磁盘上的一组文件
- 用户会话是连接到服务器进程的用户进程

## 实例内存结构
- 实例共享内存是系统全局区（SGA）,由所有会话更新，在启动实例时分配。
- 会话的专用区域是程序全局区（PGA），由每个会话专用，PGA根据需要分配。
- SGA由一组子结构组成，其中一些是必须的（数据缓存区缓存，日志缓冲区和共享池），而另外一些是可选的（大池，Java池，流池）
- 可以动态重调SGA结构的大小，也可以对其进行自动化管理，但日志缓冲区除外
- 会话写入到自身的PGA，也写入SGA。

## 实例内存结构
- 当用户连接时，将根据需要启动会话服务器进程
- 后台进程在启动实例时启动，在关闭实例前一直存在
- 服务器进程从数据库读取，后台进程对数据库执行写操作
- 某些后台进程始终存在，而其他进程根据启用的选项运行

## 数据库存储结构
- 数据库中由三类必要的文件：控制文件，联机重做日志文件和数据文件。
- 控制文件存储完整性信息以及指向数据库其余部分的指针
- 联机重做日志存储应用与数据库的更新变更向量
- 数据文件存储数据
- 外部文件包括：参数文件、口令文件、归档重做日志文件以及日志和跟踪文件。
- 表空间将逻辑数据存储从物理数据存储中抽象出来表空间可由多个数据文件组成
- 一个段包含多个区块，一个区块包含多个Oracle块，一个Oracle块包含多个操作系统块。
- 一个段可以包含位于多个数据文件的区间

## 易错点
- SGA必须的三个区：数据缓冲区缓存，日志缓冲区，共享池
- 在SGA内存结构中，除了日志缓冲区的大小固定不变，在启动实例时被设置为固定值，无法对其进行自动管理外，其余的数据缓冲区缓存，共享池，Java池，大池，流池的大小都是可变的，可以进行自动管理。
- 后台进程中：ARCN归档进程时可选的，ckpt（检查点进程），DBWR（数据库写入器），LGWR（日志写入器），MMON(可管理性监视器)进程都是必须的。
- commit时，日志写入器将日志缓冲区转储到磁盘，其他后台进程都不需要做。
- 如果表空间由多个数据文件，段可以在所有文件中拥有区间。
- 要使数据库正常工作，至少需要两个包含一个成员的组。
- 检查点进程将RBA写入控制文件。


# 5 Oracle存储结构
数据库包括三类文件：控制文件、联机重做日志文件和数据文件。

## 5.1 表空间和数据文件

逻辑上：数据存储在段中
物理上：数据存储在数据文件中
表空间（tablespace）实体是二者的抽象，一个表空间可能包含多个段，并由多个数据文件组成。

### 5.1.1 Oracle数据存储模型

将逻辑存储与物理存储分开是关系数据库范例的必要部分。

表空间实体消除了段与数据文件之间的多对多关系。一个表空间可以包含多个段，而且可以由多个数据文件组成。一个段可以分布在多个数据文件中，而任一数据文件可以包含多个段的全部或者一部分。

“段”实体表示存储数据从而需要表空间中的空间的任何数据库对象。

Oracle块是数据库的基本I/O单元。
操作系统块是文件系统的I/O单元。

### 5.1.2 段、区间、块和行

段类型总结：
- TABLE 这些是包含数据行的堆结构的表。
- INDEX 索引是键值的有序列表，相应的指针ROWID指向每行的物理位置。
- TYPES UNDO 这些是撤销段，存储数据的更改前版本，为了提供完整性，这些是必须的。
- ROLLBACK 回滚段。
- TABLE PARTITION 可以将表分成多个分区。
- INDEX PARTITION 对索引进行分区，对表上的索引进行分区。
- LOBSEGMENT、LOBINDEX、LOB PARTITION
- CLUSTER cluster段包含多个表。
- NESTED TABLE 列可以作为嵌套表，存储在自身的段中。

### 5.1.3 文件存储技术

数据文件可以保存在四类设备上：本地文件系统、群集文件系统、原始设备和ASM磁盘组

- 本地文件系统上的文件：最简单的数据文件，是磁盘目录结构的普通操作系统文件。

- 群集文件系统上的文件：调停群集中所有的计算机上运行的进程到磁盘的访问。

- 原始设备上的文件：可能在根本没有文件系统的磁盘上创建数据文件。

- ASM设备上的文件：这是文件系统的替代品，基于数据文件存储。ASM是用于Oracle数据库文件的逻辑卷管理器。

**考点：ASM只能存储数据库文件，不能存储二进制文件。始终必须将Oracle主目录保存在常规文件系统上。**

## 5.2 创建和管理表空间

### 5.2.1 创建表空间

使用enterprise manager database control创建表空间

- Allocated size(分配的大小)
- Space used(使用的空间)
- Allocated space used(%)(已使用的分配空间百分比)
- Allocated free space(分配的可用空间)
- Status(状态)：绿色对勾指示表空间处于联机状态，脱机表空间用红色错误标记表示。
- Datafiles(数据文件)
- Type(类型)
- Extent management(扩展管理)
- Segment management(段管理)

### 5.2.2 更改表空间

- 重命名：ALTER TABLESPACE tablespaceoldname RENAME TO tablespacenewname;
- 使其联机或脱机:ALTER TABLESPACE tablespacename OFFLINE [NORMAL | TIMEDIATE | TEMPORARY];
- 标记为读写或只读:ALTER TABLESPACE tablespacename [READ ONLY | READ WRITE];
- 重调大小:ALTER DATABASE DATAFILE filename RESIZE n[M|G|T];
- 更改报警阈值

### 5.2.3 删除表空间
DROP TABLESPACE tablespacename [INCLUDING CONTENTS [AND DATAFILES]]

### 5.2.4 OMF(Oracle-Managed Files)

## 5.3 管理表空间中的空间

- 将空间分配给表空间
- 将表空间中的空间分配给段
- 将段中的空间分配给行

### 5.3.1区间管理

- 始终使用本地管理，绝不使用字典管理
- 字典管理
- 本地管理

### 5.3.2管理段空间

- 始终使用自动管理，绝不使用手动管理
- 自动管理
- 手动管理
